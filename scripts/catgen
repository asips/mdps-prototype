#!/usr/bin/env python3
"""Create a STAC Catalog from file glob patterns.
"""
import argparse
import logging
import os
from datetime import datetime
from pathlib import Path

import fnmeta
import pystac
from pystac import Asset, Catalog, CatalogType, Item

LOG = logging.getLogger(Path(__file__).name)


def get_times(fpath: Path) -> "tuple[datetime, datetime] | None":
    meta = fnmeta.identify(fpath.name) or {}
    if fpath.suffix.lower() == ".pds" and "created" in meta:
        return meta["created"], meta["created"]
    if "begin_time" in meta and "end_time" in meta:
        return meta["begin_time"], meta["end_time"]
    if "begin_time" in meta:
        return meta["begin_time"], meta["begin_time"]
    return None


def generate_catalog(
    patterns: list[str], basedir: Path, include_metadata_for_mdps: bool = False
) -> Catalog:
    catalog = Catalog("catgen", "catalog generated by catgen")
    for i, pattern in enumerate(patterns):
        collection_id = ""
        if "," in pattern:
            pattern, collection_id = pattern.rsplit(",", 1)
        subcat = Catalog(
            collection_id or f"collection-{i}", f"subcatalog for pattern {pattern}"
        )
        dirpath, pattern = os.path.split(pattern)
        for fpath in Path(dirpath).glob(pattern):
            LOG.debug("adding %s to collection %s", fpath, collection_id)
            times = get_times(fpath)
            if not times:
                LOG.warning(
                    "failed to determine file times for %s; skipping", fpath.name
                )
                continue
            start, end = times
            try:
                item = Item(
                    id=fpath.name.rsplit(".", 1)[0],
                    geometry=None,
                    bbox=None,
                    properties={},
                    datetime=start,
                    start_datetime=start,
                    end_datetime=end,
                    assets={"data": Asset(href=str(fpath.absolute()), roles=["data"])},
                    # set collection kws only if one was specified as part of pattern
                    **({"collection": collection_id} if collection_id else {}),  # type: ignore
                )
                subcat.add_item(item)
            except pystac.STACError:
                LOG.exception("failed to create or add item for %s", fpath.name)
                continue
        catalog.add_child(subcat)
    catalog.normalize_hrefs(str(basedir))
    catalog.make_all_asset_hrefs_relative()
    catalog.save(catalog_type=CatalogType.SELF_CONTAINED)

    if include_metadata_for_mdps:
        # HACK: MDPS requires the item json file written above be added to the generated catalog,
        # for now anyways. This should be removed when this requirement is lifted.
        for item in catalog.get_items(recursive=True):
            data_asset = item.assets["data"]  # we know data asset exists
            meta_path = Path(data_asset.href).with_suffix(".json")
            LOG.debug("adding metadata %s", meta_path)
            item.add_asset("metadata", Asset(href=str(meta_path), roles=["metadata"]))

        catalog.normalize_hrefs(str(basedir))
        catalog.make_all_asset_hrefs_relative()
        catalog.save(catalog_type=CatalogType.SELF_CONTAINED)

    return catalog


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", action="store_true")
    parser.add_argument(
        "--include-metadata-for-mdps",
        action="store_true",
        help="include catalog item JSON as asset as required by MDPS",
    )
    parser.add_argument(
        "-p",
        "--file-pattern",
        action="append",
        metavar="PATTERN",
        dest="patterns",
        required=True,
        help=(
            "Glob style file pattern(s) to include in catalog. This can optionally "
            "be a comma separated <pattern>,<collection_id> where each file matched "
            "by the pattern will get a collection property set to collection_id. If "
            "not comma separated items will have no collection property."
        ),
    )
    parser.add_argument(
        "-o",
        "--outdir",
        type=Path,
        default=Path("."),
        help="Directory to output catalgo to. Created if it does not exist",
    )
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO, format="%(message)s")
    LOG.setLevel(logging.DEBUG if args.verbose else logging.INFO)

    catalog = generate_catalog(
        args.patterns,
        basedir=args.outdir,
        include_metadata_for_mdps=args.include_metadata_for_mdps,
    )

    if args.verbose:
        catalog.describe(include_hrefs=True)
